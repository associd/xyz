<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="utils.js"></script>
   <script src="drag.js"></script>
   <script src="partical.js"></script>
   <style media="screen">
      *{
         margin: 0;
         padding: 0;
      }
      html,body{
         height: 100%;
         overflow: hidden;
      }
      .paddle{
         width: 200px;
         height: 100px;
         background: linear-gradient(to left, rgba(248,228,78,0.5), rgba(240,66,53,0.5));
         font-size: 30px;
         line-height: 100px;
         text-align: center;
      }
      .box{
         width: 500px;
         height: 500px;
         position: fixed;
         left: 0;
         bottom: 0;
         right: 0;
         top: 0;
         margin: auto;
         background-color: skyblue;
      }
      .drag{
         position: absolute!important;
         left: 0;
         top: 0;
         /*margin 必须是0*/
         margin: 0!important;
         -moz-user-select: none;
         user-select: none;
      }
      .drag:hover{
         cursor: grab;
         cursor: -webkit-grab;
      }
      #forefront{
         position: fixed;
         z-index: 999;
         display: block;
         pointer-events: none;
      }
   </style>
</head>
<body>
   <canvas id="forefront" width="300" height="300"></canvas>
   <canvas class="friablePaddle drag" width="200" height="100"></canvas>
   <!-- <div class="box drag">
      <div class="paddle drag">拖拽</div>
   </div> -->
   <script type="text/javascript">

      webInit()

      //canvas 毁天灭地
      var cvs = e("#forefront")
      //动画开始
      var animation = Animation(cvs)
      //canvas 永远沾满屏幕
      fullWindow(cvs)
      window.addEventListener("resize", function() {
         fullWindow(cvs)
      })

      //填充画布内容
      es(".friablePaddle").forEach(function(item) {
         var ctx = item.getContext("2d")
         var grd = ctx.createLinearGradient(0, 0, item.width, 0)
         var text = "托拽至边缘"
         grd.addColorStop(0, "rgba(240,66,53,0.5)")
         grd.addColorStop(1, "rgba(248,228,78,0.5)")
         ctx.fillStyle = grd
         ctx.fillRect(0,0, item.width, item.height)
         ctx.font = "30px Microsoft YaHe"
         ctx.fillStyle = "black"
         ctx.textBaseline = "middle"
         var textWidth = ctx.measureText(text).width
         ctx.fillText(text, (item.width / 2) - (textWidth / 2), item.height / 2)
      })

      //所有class名中 包含drag类名的html元素 都能拖拽
      drag(function(ele, x, y) {
         //对于特别的canvas 会有粒子效果
         if(ele.classList.contains("friablePaddle") && ele.nodeName == "CANVAS") {
            let ctx = ele.getContext("2d")
            let size = 10
            let count = ele.offsetHeight
            let i = 1

            //粒子属性 默认在左边
            let ax = 0
            let ay = 0
            let px = function() {
               return x
            }
            let py = function() {
               return y + i
            }
            let vx = function() {
               return rand(-500, 500) / 100
            }
            vy = function() {
               return rand(500, 1000) / 100
            }

            //imageData 切割参数
            let offsetX = -x
            let offsetY = 0
            let w = 1
            let h = ele.height

            //判断ele在window里的什么位置
            if(x < 0) {
               //左
               px = function() {return -size}
               vx = function() {
                  return rand(100, 800) / 100
               }
            }else if(x > window.innerWidth - ele.offsetWidth) {
               //右
               px = () => {return window.innerWidth}
               vx = function() {
                  return rand(-100, -500) / 100
               }

               offsetX = window.innerWidth - x
            }else {
               //在y 方向上溢出
               count = ele.offsetWidth
               px = function() {
                  return x + i
               }

               offsetX = 0
               w = ele.height
               h = 1

               if(y < 0) {
                  //上
                  py = function() {return -size}

                  offsetY = - y
               }else if(y > window.innerHeight - ele.offsetHeight) {
                  //下
                  ay = 0.2
                  py = () => {return window.innerHeight}
                  vy = () => {return -rand(500, 1000) / 100}

                  offsetY = window.innerHeight - y
               }else {
                  log("狗屎")
               }
            }

            let imageData = ctx.getImageData(offsetX, offsetY, w, h).data

            for(i=0; i < count; i++) {
               let color = `rgba(${imageData[i * 4 + 0]}, ${imageData[i * 4 + 1]}, ${imageData[i * 4 + 2]}, ${imageData[i * 4 + 3]})`
               let p = CreatePartical(px(), py())
               p.init(vx(), vy(), ax, ay, size)
               p.color = color
               animation.addElement(p)
            }
         }
      })
   </script>
</body>
</html>
